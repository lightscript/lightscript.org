<!DOCTYPE html>
 <html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title> | LightScript</title><link rel="stylesheet" href="//code.cdn.mozilla.net/fonts/fira.css"/><style>.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></head><body><div id="react-mount"><div data-reactroot="" data-reactid="1" data-react-checksum="1603605929"><nav class="navbar navbar navbar-toggleable navbar-light mb-1" style="background-color:#DAF3FF;border-bottom:1px solid #CBE2EC;" data-reactid="2"><div class="row justify-content-md-center w-100" data-reactid="3"><div class="col-6" data-reactid="4"><a class="navbar-brand" href="/" data-reactid="5">LightScript</a></div><div class="navbar-nav float-right col-auto" data-reactid="6"><a class="nav-item nav-link active" href="/docs/" data-reactid="7">Documentation</a><a href="https://github.com/lightscript/lightscript" class="nav-item nav-link" data-reactid="8">Github</a></div></div></nav><div class="markdown" data-reactid="9"><h1 data-reactid="10"></h1><div data-reactid="11"><h2>TOC</h2>
<h2>Variables &amp; Assignment</h2>
<h3><code>const</code></h3>
<p>LightScript is <code>const</code> by default; the keyword is not necessary:</p>
<pre><code>greeting = 'Hello, World!'
</code></pre>
<p>This is also true when destructuring:</p>
<pre><code>{ color, owner } = lightsaber
</code></pre>
<p>Because LightScript is a (rough) superset of JavaScript,
the <code>const</code> keyword is also valid:</p>
<pre><code>const greeting = 'Hello, World!'
</code></pre>
<p>LightScript uses Facebook’s <a href="https://flow.org/">Flow</a> typechecker and type syntax,
so you can optionally annotate types:</p>
<pre><code>greeting: string = 'Hello, World!'
</code></pre>
<p>As a rule of thumb, anywhere you can use Flow syntax in JavaScript,
you can use the same syntax in LightScript.</p>
<p>Integration with the Flow typechecker has <strong>not been built yet</strong>,
so while you can annotate your types, they will not yet be statically checked.
This is blocking on <a href="https://github.com/facebook/flow/issues/1515">Flow accepting an AST as input</a>.
As a stopgap, the <code>babel-preset-lightscript</code> may include
<a href="https://github.com/gcanti/babel-plugin-tcomb">tcomb</a>, which provides runtime typechecks.</p>
<p>Note that, unlike in JavaScript, the <code>:</code> cannot be followed by a newline.</p>
<h3><code>let</code> and <code>var</code></h3>
<p><code>let</code> and <code>var</code> are the same as in JavaScript.</p>
<pre><code>let friendCount = 1
</code></pre>
<p>However, to reassign a variable, you must use the keyword <code>now</code>:</p>
<pre><code>let friendCount = 1
// makes a friend...
now friendCount = 2
</code></pre>
<h3>Updating values</h3>
<p>Reassigning or updating a variable requires the <code>now</code> keyword.
This makes it more clear when you are reassigning
(which shouldn’t be often), and enables the <code>const</code>-by-default syntax.</p>
<pre><code>let isDarkSide = false
// ... gets stuck in traffic ...
now isDarkSide = true
</code></pre>
<p>Assignments that update a variable also require the <code>now</code> keyword:</p>
<pre><code>let planetsDestroyed = 0
// the death star is fully operational
now planetsDestroyed += 1
</code></pre>
<p>However, assigning to an object’s property allows, but does not require <code>now</code>:</p>
<pre><code>now milleniumFalcon.kesselRun = 'less than 12 parsecs!'

milleniumFalcon.kesselRun = 'less than 12 parsecs!'
</code></pre>
<p>Similarly, non-assignment updates allow but do not currently require <code>now</code>:</p>
<pre><code>now planetsDestroyed++
planetsDestroyed++
</code></pre>
<h3>Shadowing Variables</h3>
<p>You cannot shadow a variable using <code>const</code> shorthand:</p>
<pre><code>let myVar = 2
if (true) {
  myVar = 3
}
</code></pre>
<p>The above is not allowed because it looks ambiguous and confusing;
did you mean to declare a new variable, or were you trying to update
the existing variable, and just forgot to use <code>now</code>?</p>
<p>Instead, you must explictly use either <code>now</code> or <code>const</code>:</p>
<pre><code>let myVar = 2
if (true) {
  const myVar = 3
}
myVar === 2 // true

let myOtherVar = 4
if (true) {
  now myOtherVar = 5
}
myOtherVar === 5 // true
</code></pre>
<h2>Whitespace</h2>
<p>Since (almost) all valid JavaScript is valid LightScript,
you can write loops and conditionals as you always would, complete with parens and curlies.</p>
<p>You can write <code>if</code>, <code>for</code>, etc without parens, but with curly braces:</p>
<pre><code>for const x of arr {
  if x &gt; 10 {
    print('wow, so big!')
  } else {
    print('meh')
  }
}
</code></pre>
<p>Or, if you prefer, use significant indentation:</p>
<pre><code>for const x of arr:
  if x &gt; 10:
    print('wow, so big!')
  else:
    print('meh')
</code></pre>
<p>This “curly-or-whitespace” option is also available for class and function bodies.</p>
<p>Whitespace (significant indentation) is often more concise and readable for simple code,
but when blocks get very long or deeply nested, curly braces offer better visibility. Teams have the freedom to choose a style that feels comfortable.</p>
<h3>One-line syntax</h3>
<p>Blocks that contain only a single statement can be written on the same line:</p>
<pre><code>for elem thing in list: print(thing)

if x &lt; 10: print('x is small')
</code></pre>
<p>One-line blocks can be combined:</p>
<pre><code>for elem x in arr: if x &lt; 10: print(x)
</code></pre>
<p>You cannot, however, mix one-line and multiline syntax:</p>
<pre><code>for x of arr: print(x)
  print('This is broken.')
</code></pre>
<h3>What constitutes indentation?</h3>
<p>An indent is two spaces, period.</p>
<p>LightScript only allows “normal” (ascii-32) whitespace;
tabs, non-breaking spaces, and other invisible characters raise a SyntaxError.
Similarly, only <code>\n</code> and <code>\r\n</code> are valid line terminators.</p>
<p>Overindentation is currently allowed, but discouraged. It may be made illegal in the future.</p>
<h3>When does an indent end?</h3>
<p>An indented block is parsed until the indent level of a line is less than or equal to
the indent level of the line that started the block (the line with a <code>:</code> or <code>-&gt;</code>).</p>
<p>For example, this does not work:</p>
<pre><code>if treeIsPretty and
  treeIsTall:
  climbTree()
</code></pre>
<p>but this does (because the line with the <code>:</code> has one indent):</p>
<pre><code>if treeIsPretty and
  treeIsTall:
    climbTree()
</code></pre>
<p>However, that’s a little ugly; the recommended style would be:</p>
<pre><code>if (
  treeIsPretty and
  treeisTall
):
  climbTree()
</code></pre>
<h2>Conditionals</h2>
<h3><code>elif</code></h3>
<p>The same as <code>else if</code>, which you can also use:</p>
<pre><code>if awesome:
  jumpForJoy()
elif great:
  highFive()
else if good:
  smileMeekly()
else:
  cringe()
</code></pre>
<h3><code>if</code> expressions</h3>
<p>In LightScript, ternaries look like <code>if</code>s:</p>
<pre><code>animal = if canBark: 'dog' else: 'cow'
</code></pre>
<h3>Multiline <code>if</code> expressions</h3>
<pre><code>animal =
  if canBark:
    'dog'
  elif canMeow:
    print('These ternaries can take multiple expressions')
    'cat'
  else:
    'cow'
</code></pre>
<p>Note that if you move the <code>if</code> to the first line, the rest of the code
must be dedented so that the <code>else</code>s have the same indent level as <code>animal</code>.</p>
<h3><code>null</code>-default <code>if</code> expressions</h3>
<p>If you don’t include an <code>else</code>, it will be <code>null</code>:</p>
<pre><code>maybeDog = if canBark: 'dog'
</code></pre>
<h3><code>else</code> indentation</h3>
<p>When using whitespace blocks, <code>else</code> or <code>elif</code> must match the indentation of the <code>if</code>,
so this is illegal:</p>
<pre><code>if treeIsPretty and
  treeisTall:
    climbTree()
  else:
    walkAround()
</code></pre>
<p>as is this:</p>
<pre><code>f() =&gt;
    if treeIsPretty:
      climbTree()
  else:
    walkAround()
</code></pre>
<h2>Logic and Equality</h2>
<h3><code>==</code></h3>
<pre><code>1 == 1
</code></pre>
<p>Both <code>==</code> and <code>===</code> compile to <code>===</code>, which is almost always what you want.</p>
<p>When you actually want to use a loose-equals (<code>==</code>), call the <code>looseEq()</code> function
from the <a href="#standard-library">standard library</a> (eg; <code>1~looseEq('1')</code>).</p>
<h3><code>!=</code></h3>
<pre><code>1 != 0
</code></pre>
<p>Similarly, both <code>!=</code> and <code>!==</code> compile to <code>!==</code>.</p>
<p>When you actually want to use a loose-not-equals (<code>!=</code>),
call the <code>looseNotEq()</code> function from the <a href="#standard-library">standard library</a>.</p>
<h3><code>or</code></h3>
<pre><code>a or b
</code></pre>
<h3><code>and</code></h3>
<pre><code>a and b
</code></pre>
<h3><code>not</code></h3>
<pre><code>not c
</code></pre>
<p><code>not</code> may be removed from the language in the future.</p>
<h2>Functions and Methods</h2>
<p>JavaScript has half a dozen ways to define a function;
LightScript unifies that to just one, consistent across contexts.</p>
<p>The basic syntax comes from stripping down the fat arrow:</p>
<pre><code>const myFunction = (x, y) =&gt; x + y
</code></pre>
<p>to the more minimal:</p>
<pre><code>myFunction(x, y) =&gt; x + y
</code></pre>
<p>Unbound functions use a skinny arrow (<code>-&gt;</code>),
async functions use a barbed arrow (<code>-/&gt;</code> or <code>=/&gt;</code>),
and methods look the exact same as top-level functions.</p>
<p>LightScript functions have implicit returns and optional curly braces:</p>
<pre><code>myFunction(x, y) =&gt;
  print('multiplying is fun!')
  x * y

myCurlyFunction(x, y) =&gt; {
  print('adding is fun!')
  x + y
}
</code></pre>
<h3>Bound</h3>
<pre><code>foo() =&gt; this.someProp
</code></pre>
<p>Compiles to ES6 fat arrows whenever possible,
and inserts the relevant <code>.bind()</code> call otherwise.
See also <a href="#bound-methods">bound methods</a>.</p>
<p>Note that when used in an expression, the name is discarded:</p>
<pre><code>runCallback(foo() =&gt; 1)
</code></pre>
<h3>Unbound</h3>
<p>Skinny arrows (<code>-&gt;</code>) are unbound:</p>
<pre><code>ultimateQuestion() -&gt; 6 * 9

sillySumPlusTwo(a, b) -&gt;
  now a++
  now b++
  a + b
</code></pre>
<p>While you’re welcome to use <code>=&gt;</code> pretty much everywhere, there are a few advantages
of using skinny arrows:</p>
<ul>
<li><code>function</code> declarations are hoisted, meaning you can declare utility methods
at the bottom of a file, and main methods at the top.</li>
<li>Fat-arrow methods insert <code>.bind()</code> calls, which may be unncessary if the method
doesn’t actually need to be bound.</li>
</ul>
<h3>Without implicit returns</h3>
<p>To disable implicit returns for a method, give it a <code>void</code> type annotation.</p>
<pre><code>foo(): void -&gt;
  1
</code></pre>
<p>LightScript does not add implicit returns:</p>
<ul>
<li>To functions with a <code>void</code> returnType annotation (eg; <code>fn(): void -&gt;</code>).</li>
<li>To setter methods (eg; <code>{ prop(newValue) -set&gt; this._prop = newValue }</code>).</li>
<li>To constructor methods (eg; <code>constructor() -&gt;</code>), which generaly should not return.</li>
</ul>
<h3>Annotated</h3>
<p>LightScript uses Facebook’s <a href="https://flow.org/">Flow</a> typechecker and type syntax.</p>
<pre><code>foo(a: string, b: number): number -&gt;
  a.length + b
</code></pre>
<p>Polymorphic:</p>
<pre><code>foo&lt;T&gt;(a: T): T -&gt; a
</code></pre>
<h3>Anonymous</h3>
<pre><code>runCallback(() -&gt; 42)
runCallback(param -&gt; param * 2)
runCallback(param =&gt; param * 2)
</code></pre>
<h3>Async</h3>
<pre><code>foo() -/&gt;
  Promise.resolve(42)

boundFoo() =/&gt;
  Promise.resolve(this.answer + 42)
</code></pre>
<p>See also <a href="#await">await</a>.</p>
<h3>Generators</h3>
<pre><code>foo() -*&gt;
  yield 3
  yield 4
</code></pre>
<p>Note that JavaScript does not support fat-arrow generator functions;
LightScript compiles them to bound functions:</p>
<pre><code>boundFoo() =*&gt;
  yield 3
  yield 4
</code></pre>
<h3>Async Generators</h3>
<p>If you are using the
<a href="https://babeljs.io/docs/plugins/transform-async-generator-functions/"><code>async-generator-functions</code> babel transform</a>,
you can define async generators with <code>-*/&gt;</code> and <code>=*/&gt;</code>.
Note that this is (at time of writing) a stage 3 proposal
and thus not yet part of <code>babel-preset-env</code> or any browers.</p>
<h3>Basic Methods</h3>
<pre><code>obj = {
  foo() -&gt; 'hello'
  bar() -&gt;
    'hi there'
}
</code></pre>
<h3>Bound Methods</h3>
<pre><code>obj = {
  name: 'Jack'
  loudName() =&gt; this.name.toUpperCase()
}
</code></pre>
<h3>Getters and Setters</h3>
<pre><code>obj = {
  foo() -get&gt; this._foo
  foo(newValue) -set&gt; this._foo = newValue
}
obj.foo = 'hi'
obj.foo
</code></pre>
<p>See also <a href="#classes">Classes</a>.</p>
<p>Note that fat arrows (<code>=get&gt;</code> and <code>=set&gt;</code>) are not available,
as getters and setters generally do not require binding.</p>
<p>Note also that <code>-get&gt;</code> and <code>-set&gt;</code> cannot be combined with <code>-/&gt;</code> or <code>-*&gt;</code> syntax.</p>
<h2>Await</h2>
<pre><code><span class="hljs-function"><span class="hljs-title">getData</span><span class="hljs-params">(url)</span> -/&gt;
  <span class="hljs-title">response</span> &lt;- <span class="hljs-title">fetch</span><span class="hljs-params">(url)</span>
  &lt;- <span class="hljs-title">response</span>.<span class="hljs-title">json</span><span class="hljs-params">()</span>
</span></code></pre>
<h3>Await and Assign</h3>
<p>To assign to a <code>const</code>, supply a variable name on the left side of the arrow:</p>
<pre><code>getData(<span class="hljs-name">url</span>) -/&gt;
  response &lt;- fetch(<span class="hljs-name">url</span>)
  response
</code></pre>
<p>To reassign an existing variable, use <code>now</code>:</p>
<pre><code><span class="hljs-title">reassignData</span>(<span class="hljs-class"><span class="hljs-keyword">data</span>) -/&gt;</span>
  now <span class="hljs-class"><span class="hljs-keyword">data</span> &lt;- asyncTransform(<span class="hljs-title">data</span>)</span>
  <span class="hljs-class"><span class="hljs-keyword">data</span></span>
</code></pre>
<p>If you are mutating an object’s property, <code>now</code> is optional:</p>
<pre><code><span class="hljs-function"><span class="hljs-title">reassignDataProp</span><span class="hljs-params">(obj)</span></span> -/&gt;
  now obj<span class="hljs-selector-class">.data</span> &lt;- process(obj.data)
  obj<span class="hljs-selector-class">.data</span> &lt;- process(obj.data)
  obj
</code></pre>
<p>Note that in all cases, the <code>&lt;-</code> must be on the same line as the variable.</p>
<h3>Await without Assign</h3>
<p>A <code>&lt;-</code> that begins a line is a “naked await”:</p>
<pre><code>delayed(<span class="hljs-name">action</span>, delay) -/&gt;
  &lt;- waitFor(<span class="hljs-name">delay</span>)
  action()
</code></pre>
<p>It can be implicitly returned like anything else:</p>
<pre><code><span class="hljs-function"><span class="hljs-title">getData</span><span class="hljs-params">(url)</span> =/&gt;
  <span class="hljs-title">response</span> &lt;- <span class="hljs-title">fetch</span><span class="hljs-params">(url)</span>
  &lt;- <span class="hljs-title">response</span>.<span class="hljs-title">json</span><span class="hljs-params">()</span>
</span></code></pre>
<h3>Await Array</h3>
<p>When an <code>await</code> is followed by a <code>[</code>, it is wrapped in <code>Promise.all()</code>:</p>
<pre><code><span class="hljs-function"><span class="hljs-title">fetchBoth</span><span class="hljs-params">(firstUrl, secondUrl)</span> -/&gt;
  &lt;- [<span class="hljs-title">fetch</span><span class="hljs-params">(firstUrl)</span>, <span class="hljs-title">fetch</span><span class="hljs-params">(secondUrl)</span>]
</span></code></pre>
<p>You do not need to use the <code>&lt;-</code> symbol to take advantage of this:</p>
<pre><code><span class="hljs-function"><span class="hljs-title">fetchBoth</span><span class="hljs-params">(firstUrl, secondUrl)</span> -/&gt;
  <span class="hljs-title">return</span> <span class="hljs-title">await</span> [<span class="hljs-title">fetch</span><span class="hljs-params">(firstUrl)</span>, <span class="hljs-title">fetch</span><span class="hljs-params">(secondUrl)</span>]
</span></code></pre>
<p>You cannot pass a value that happens to be an array; it must be contained in <code>[]</code>:</p>
<pre><code><span class="hljs-function"><span class="hljs-title">awaitAll</span><span class="hljs-params">(promises)</span></span> -/&gt;
  &lt;- promises
</code></pre>
<p>doesn’t work, but this does:</p>
<pre><code><span class="hljs-function"><span class="hljs-title">awaitAll</span><span class="hljs-params">(promises)</span></span> -/&gt;
  &lt;- [...promises]
</code></pre>
<p>This can alo be combined with Array Comprehensions:</p>
<pre><code><span class="hljs-function"><span class="hljs-title">fetchAll</span><span class="hljs-params">(urls)</span></span> -/&gt;
  &lt;- [<span class="hljs-keyword">for</span> elem url <span class="hljs-keyword">in</span> urls: fetch(url)]
</code></pre>
<h3>Safe Await</h3>
<p>The most likely source of errors in any application should occur at I/O boundaries,
which are also typically crossed asynchronously. Any time you <code>fetch()</code> across a network,
you should expect it to fail some percentage of the time, and prepare accordingly.</p>
<p>In JavaScript, this can be inconvenient:</p>
<pre><code>getData(url) -/&gt;
  let response
  try {
    now response = await fetch(url)
  } catch (err) {
    handle(err)
    return
  }
  return await response.json()
</code></pre>
<p>The small try/catch blocks are annoying and force you to use unnecessary <code>let</code>s.
The alternative is to put all logic using the <code>await</code>ed value into the <code>try</code> block,
which is also an anti-pattern.</p>
<p>In LightScript, you can easily wrap an await in a try/catch:</p>
<pre><code>getData(url) -/&gt;
  <span class="hljs-built_in">response</span> &lt;!- fetch(url)

  <span class="hljs-keyword">if</span> isError(<span class="hljs-built_in">response</span>):
    handle(<span class="hljs-built_in">response</span>)
    return

  &lt;- <span class="hljs-built_in">response</span>.json()
</code></pre>
<p>This pattern is much closer to the &quot;safely handle errors within normal control-flow&quot;
philosophy of Rust, Haskell, and Go, which use <code>Result</code>, <code>Maybe</code>, or multiple return values.</p>
<p>Because LightScript uses Flow for static type checking, any code that follows a
<code>&lt;!-</code> must handle the error case.</p>
<h2>Property Access</h2>
<h3>Null-Safe Property Access</h3>
<p><em>(also known as safe navigation operator, optional chaining operator, safe call operator, null-conditional operator)</em></p>
<pre><code>lacesOrNull = hikingBoots?.laces
</code></pre>
<p>This also works with computed properties:</p>
<pre><code>treeTrunk?.rings?[age]
</code></pre>
<p>Safe chains that contain methods will not be called more than once:</p>
<pre><code>getDancingQueen()?.feelTheBeat(tambourine)

getDanceFloor().dancingQueen?.isSeventeen
</code></pre>
<p>Note that the default value is <code>null</code>, unlike CoffeeScript’s <code>undefined</code>.</p>
<h3>Numerical Index Access</h3>
<pre><code>firstChance = chances.0
secondChance = chances.1
</code></pre>
<p>This is a minor feature to make chaining more convenient, and may be removed in the future.</p>
<p>There is not a negative index feature (eg; <code>chances.-1</code> doesn’t work),
but with the standard library you can write:</p>
<pre><code>lastChance = chances~last()
</code></pre>
<p>This uses the <a href="#tilde-calls">Tilde Call</a> feature and the <code>lodash.last()</code> function,
which LightScript makes available as its <a href="#standard-library">standard library</a>.</p>
<h3>Property function definition</h3>
<p>You can define properties that are functions using the standard LightScript arrow syntax:</p>
<pre><code>mammaMia.resistYou() -&gt; false

mammaMia.hereWeGo() =&gt; this.again

Mamma.prototype.name() -&gt; &quot;Mia!&quot;
</code></pre>
<h2>Tilde Calls</h2>
<p>This is a headline feature of LightScript, and a slightly unique mix of
Kotlin’s Extensions Methods, Ruby’s Monkey Patching, and Elixir’s Pipelines.</p>
<pre><code>subject~verb(object)
</code></pre>
<p>The underlying goal is to encourage the functional style of separating
immutable typed records from the functions that go with them,
while preserving the human-readability of “subject.verb(object)” syntax
that Object-Oriented methods provide.</p>
<p>It enables slightly more readable code in simple situations:</p>
<pre><code>if response~isError():
  freakOut()
</code></pre>
<!-- -->
<pre><code>money = querySelectorAll('.money')
money~map(mustBeFunny)
</code></pre>
<p>And makes chaining with functions much more convenient, obviating intermediate variables:</p>
<pre><code>allTheDucks
  .map(duck =&gt; fluffed(duck))
  ~uniq()
  ~sortBy(duck =&gt; duck.height)
  .filter(duck =&gt; duck.isGosling)
</code></pre>
<p>Note that all lodash methods are included in the LightScript <a href="#standard-library">standard library</a>.</p>
<h2>Objects</h2>
<p>See also <a href="#methods">Methods</a>.</p>
<h3>Single-Line Objects</h3>
<p>The same as JavaScript (ES7):</p>
<pre><code>obj = { a: 'a', b, [1 + 1]: 'two' }
</code></pre>
<p>For all ES7 features, use <code>babel-preset-lightscript</code> instead of <code>babel-plugin-lightscript</code>
or include the babel plugins directly.</p>
<h3>Multi-Line Objects</h3>
<p>Commas are optional; newlines are preferred.</p>
<pre><code>obj = {
  a: 'a'
  b
  method() =&gt;
    3
  [1 + 1]: 'two'
}
</code></pre>
<h2>Arrays</h2>
<h3>Single-Line Arrays</h3>
<p>The same as JavaScript.</p>
<pre><code>arr = [1, 2, 3]
</code></pre>
<h3>Multi-Line Arrays</h3>
<p>Again, commas are optional; newlines are preferred.</p>
<pre><code>arr = [
  1
  2
  2 + 1
  5 - 1
  5
]
</code></pre>
<h2>Loops</h2>
<p>In JavaScript, there’s really only one fast option for iteration: <code>for-;;</code>.
It’s so ugly, though, that most developers avoid it in favor of more ergonomic
(but less performant and powerful) alternatives, like <code>.forEach()</code> and <code>for-of</code>.</p>
<p>With LightScript, you don’t have to compromise.</p>
<h3>Iterating over Arrays</h3>
<p>Iterate over indices and elements of an array:</p>
<pre><code>for idx i, elem x in arr:
  print(i, x)
</code></pre>
<p>Only indices:</p>
<pre><code>for idx i in arr:
  print(i)
</code></pre>
<p>Only elements:</p>
<pre><code>for elem x in arr:
  print(x)
</code></pre>
<p>Note that if you are iterating over something more complicated than a variable
(eg; a function call), it will be lifted into its own variable so as not to be called twice:</p>
<pre><code>for elem x in foo():
  print(x)
</code></pre>
<h3>Iterating over Objects</h3>
<p>Iterate over keys and values of an object:</p>
<pre><code>for key k, val v in obj:
  print(k, v)
</code></pre>
<p>Only keys:</p>
<pre><code>for key k in obj:
  print(k)
</code></pre>
<p>Only values:</p>
<pre><code>for val v in obj:
  print(v)
</code></pre>
<p>Note the use of <code>Object.keys()</code> under the hood, as this will only iterate over
<em>own</em> keys, not inherited ones. Use a <a href="#traditional-for-in">traditional <code>for-in</code></a>
if you wish to iterate over inherited properties as well.</p>
<h3>Iterating over Ranges</h3>
<p>There is no builtin support for ranges.
When the object instantiation is acceptable, use of <code>Array()</code>
or the lodash <code>range()</code> method (provided by <a href="#standard-library">the stdlib</a>)
is recommended:</p>
<pre><code>for idx i in Array(10):
  print(i)
</code></pre>
<!-- -->
<pre><code>for idx i in range(20, 100, 2):
  print(i)
</code></pre>
<p>If you are performing a numerical iteration and the array instantiation is problematic
for performance, <code>for-;;</code> is recommended:</p>
<pre><code>for let i = 0; i &lt; n; i++:
  print(i)
</code></pre>
<h3>Destructuring elements or values</h3>
<p>You can destructure the elements of an Array or the values of an Object, similar to ES2015 JavaScript:</p>
<p>Array element destructuring:</p>
<pre><code>for elem { color } in [{ color: 'blue' }]:
  print(color)
</code></pre>
<p>Object value destructuring:</p>
<pre><code>for val [first, second] in { bases: ['who', 'what'] }:
  print(first, second)
</code></pre>
<p>The full power of <a href="https://mdn.io/destructuring_assignment">destructuring syntax</a> is possible here:</p>
<pre><code>for elem { props: { color, size: [w, h] }  } in arr:
  print(color, w, h)
</code></pre>
<h3>Traditional <code>for-in</code></h3>
<p>If you wish to iterate over all owned <em>and inherited</em> keys of an object,
use <code>for-in</code> with <code>const</code>, <code>let</code>, <code>var</code>, or <code>now</code>:</p>
<pre><code>for const k in obj:
  print(k)
</code></pre>
<!-- -->
<pre><code>var k;
for now k in {a: 1, b: 2}:
  print()

print(k)
// &quot;b&quot;
</code></pre>
<p>Unfortunately, the more concise <code>for x in arr</code> form would be ambiguous
(is it keys of an object or values of an array?) and is not allowed:</p>
<pre><code>for x in arr:
  print(x)
</code></pre>
<h3>Traditional <code>for-of</code></h3>
<p>If you are iterating over <code>[Symbol.iterator]</code> (eg; a generator function),
use <code>for-of</code> as in JS.</p>
<p>A construct like <code>for iter x in gen</code> may be introduced in the future for consistency.</p>
<p>Like <code>for-in</code>, <code>for-of</code> must include <code>const</code>, <code>let</code>, <code>var</code>, or <code>now</code>:</p>
<pre><code>for const x of gen:
  print(gen)
</code></pre>
<p>A naked variable is not allowed:</p>
<pre><code>for x of gen():
  print(x)
</code></pre>
<p>This is to encourage developers iterating over arrays to use the more performant
<code>for elem x in arr</code> rather than <code>for x of arr</code>, which is <a href="https://jsperf.com/for-of-vs-for-loop/15">slower</a>.
It may be relaxed in the future.</p>
<h3>Single-line <code>for</code></h3>
<pre><code>for elem x in stuff: print(x)
</code></pre>
<p>This syntax can be used with all <code>for</code> loops.</p>
<p>Note that you can combine this with single-line <code>if</code> statements:</p>
<pre><code>for elem x in stuff: if x &gt; 3: print(x)
</code></pre>
<h3><code>while</code> loops</h3>
<p>As in JavaScript, with the standard syntax options:</p>
<pre><code>while true:
  doStuff()
</code></pre>
<h3><code>do-while</code></h3>
<p>As in JavaScript, with the standard syntax options:</p>
<pre><code>do:
  activities()
while true
</code></pre>
<p>A newline (or semicolon) must follow the <code>while</code> clause, so this is not legal in LightScript:</p>
<pre><code>do:
  activities()
while (true) foo()
</code></pre>
<h3><code>switch</code></h3>
<p>As in JavaScript. Curly braces around the <code>case</code>s are required;
parens around the discriminant are not:</p>
<pre><code>switch val {
  case &quot;x&quot;:
    break
  case &quot;y&quot;:
    break
}
</code></pre>
<p>This may change in the future. A <code>guard</code> or <code>match</code> feature may also be added.</p>
<h2>Comprehensions</h2>
<h3>Array Comprehensions</h3>
<pre><code>doubledItems =
  [ for elem item in array: item * 2 ]
</code></pre>
<!-- -->
<pre><code>filteredItems =
  [ for elem item in array: if item &gt; 3: item ]
</code></pre>
<p>Note that you can nest for-loops within an array, and they can take up multiple lines:</p>
<pre><code>listOfPoints = [
  for elem x in xs:
    for elem y in ys:
      if x and y:
        { x, y }
]
</code></pre>
<p>You can also nest comprehensions within comprehensions for constructing multidimensional arrays:</p>
<pre><code>matrix = [ for idx row in Array(n):
  [ for idx col in Array(n): { row, col } ]
]
</code></pre>
<p>Note that if <code>else</code> is not provided, items that do not match an <code>if</code> are filtered out; that is,</p>
<pre><code>[ for idx i in Array(5): if i &gt; 2: i ]
</code></pre>
<p>will result in <code>[3, 4]</code>, not <code>[null, null, null, 3, 4]</code></p>
<h3>Object Comprehensions</h3>
<p>As with Array Comprehensions, but wrapped in <code>{}</code> and with comma-separated <code>key, value</code>.</p>
<pre><code>{ for elem item in array: (item, f(item)) }
</code></pre>
<p>The parens are optional:</p>
<pre><code>flipped =
  { for key k, val v in obj: v, k }
</code></pre>
<h2>Classes</h2>
<h3>Basic Classes</h3>
<pre><code>class Animal {
  talk() -&gt; 'grrr'
}

class Person extends Animal:
  talk() -&gt; 'hello!'
</code></pre>
<h3>Bound Class Methods</h3>
<pre><code>class Clicker extends Component:

  handleClick(): void =&gt;
    this.setState({ clicked: true })

  render() -&gt;
    &lt;button onClick={this.handleClick}&gt;
      Click me!
    &lt;/button&gt;
</code></pre>
<p>Use a fat arrow (<code>=&gt;</code>) to bind class methods.
This will be added to the constructor after a <code>super</code> call, which will be created if it does not exist.</p>
<p>You cannot use bound class methods if you <code>return super()</code>,
which is something you typically <a href="TODO">shouldn’t do anyway</a>.</p>
<h3>Constructor and Super Insertion</h3>
<p>If you define bound class methods with <code>=&gt;</code>, a <code>constructor</code> method will be inserted
if one did not already exist.</p>
<p>LightScript will also insert <code>super()</code> for you if a <code>constructor</code> is defined
in a class that <code>extends</code> another class, and will pass along your parameters
to the base class.</p>
<pre><code>class Person extends Animal:
  constructor(foo) -&gt;
    console.log(&quot;I forgot to call super!&quot;)
</code></pre>
<p>To disable <code>super</code>-insertion, define the constructor without a LightScript arrow:</p>
<pre><code>class NaughtyPerson extends Person:
  constructor(foo) {
    console.log(&quot;I don't want super called!&quot;)
  }
</code></pre>
<h3>Bound static methods</h3>
<pre><code>class Animal:
  static kingdom() =&gt; this.name
</code></pre>
<p>In this example, <code>kingdom()</code> will always return <code>'Animal'</code>,
regardless of its calling context.</p>
<h3>Class Getters and Setters</h3>
<pre><code>class Animal:
  noise() -get&gt;
    this.sound or 'grrr'

  noise(newValue) -set&gt;
    this.sound = newValue
</code></pre>
<p>See also <a href="#object-methods">Object Methods</a>.</p>
<h3>Class properties (“class instance fields”)</h3>
<p>As in ES7:</p>
<pre><code>class Animal:
  noise = 'grrr'
</code></pre>
<p>Note that <code>babel-plugin-lightscript</code> by itself will not process class properties;
you must include the <code>babel-plugin-transform-class-properties</code> plugin yourself,
or use <code>babel-preset-lightscript</code>.</p>
<h3>Static properties and methods (“class static fields”)</h3>
<p>As in ES7:</p>
<pre><code>class Animal:
  static isVegetable = false
  static canMakeNoise() -&gt; true
</code></pre>
<h3>Decorators</h3>
<p>As in ES7:</p>
<pre><code>@classDecorator
class Animal:

  @methodDecorator
  talk() -&gt; 'grrr'
</code></pre>
<p>Note that <code>babel-plugin-lightscript</code> by itself will not process decorators;
you must include the <code>babel-plugin-transform-decorators-legacy</code> plugin yourself,
or use <code>babel-preset-lightscript</code>.</p>
<h2>Standard Library</h2>
<p>By default, LightScript makes all of Lodash available to be imported as needed:</p>
<pre><code>[0.1, 0.3, 0.5, 0.7]~map(round)~uniq()
// [0, 1]
</code></pre>
<p>There are also several non-Lodash functions available which will be inlined:</p>
<pre><code>looseEq(3, '3')
// true

2~looseNotEq('3')
// true

bitwiseNot(1)
// -2
</code></pre>
<h3>Contents</h3>
<ul>
<li>Every method in <a href="https://lodash.com/docs/4.17.4">Lodash v4</a>
<ul>
<li>Note that LightScript <strong>does not</strong> install lodash for you;
you must run <code>npm install --save lodash</code> if you wish to use these features.</li>
</ul>
</li>
<li><code>looseEq(a, b)</code>, which uses the JavaScript loose-equality <code>==</code> to compare two variables
(available because in LightScript, <code>==</code> compiles to <code>===</code>).</li>
<li><code>looseNotEq(a, b)</code>, which uses the JavaScript loose-inequality <code>!=</code> to compare two variables.</li>
<li>all the JavaScript bitwise operators
<ul>
<li><code>bitwiseNot(x)</code>, returns the result of <code>~x</code> (since <code>~</code> has been repurposed in LightScript for <a href="#tilde-calls">Tilde Calls</a>).</li>
<li><code>bitwiseAnd(a, b)</code>, returns the result of <code>a &amp; b</code>.</li>
<li><code>bitwiseOr(a, b)</code>, returns the result of <code>a | b</code>.</li>
<li><code>bitwiseXor(a, b)</code>, returns the result of <code>a ^ b</code>.</li>
<li><code>bitwiseLeftShift(a, b)</code>, returns the result of <code>a &lt;&lt; b</code>.</li>
<li><code>bitwiseRightShift(a, b)</code>, returns the result of <code>a &gt;&gt; b</code>.</li>
<li><code>bitwiseZeroFillRightShift(a, b)</code>, returns the result of <code>a &gt;&gt;&gt; b</code>.</li>
</ul>
</li>
</ul>
<h3>Overriding</h3>
<p>User-defined identifiers will override a stdlib identifier:</p>
<pre><code>round(x) -&gt; 100
[0.1, 0.3, 0.5, 0.7]~map(round)~uniq()
// [100]
</code></pre>
<p>In the future, this will be discouraged with an ESLint rule.</p>
<h3>Disabling</h3>
<p>To disable this feature, pass <code>stdlib: false</code> to <code>babel-plugin-lightscript</code>, eg;</p>
<pre><code><span class="hljs-string">//</span> <span class="hljs-string">.babelrc</span>
{
  <span class="hljs-string">"plugins"</span>: [
    [<span class="hljs-string">"lightscript"</span>, { <span class="hljs-string">"stdlib"</span>: <span class="hljs-literal">false</span> }]
  ]
}
</code></pre>
<p>You may also similarly disable inclusion of lodash:</p>
<pre><code><span class="hljs-string">//</span> <span class="hljs-string">.babelrc</span>
{
  <span class="hljs-string">"plugins"</span>: [
    [<span class="hljs-string">"lightscript"</span>, {
      <span class="hljs-string">"stdlib"</span>: {
        <span class="hljs-string">"lodash"</span>: <span class="hljs-literal">false</span>,
      }
    }]
  ]
}
</code></pre>
<p>Note that this is unlikely to be necessary;
projects that simply don’t call lodash methods won’t have any lodash imports,
and if you do the import yourself LightScript won’t add an import.</p>
<h3>Using require instead of import</h3>
<p>If you are not transpiling <code>import</code> to <code>require()</code> calls with another plugin
(or with <code>babel-preset-lightscript</code>), you may need the <code>require: true</code> setting:</p>
<pre><code><span class="hljs-string">//</span> <span class="hljs-string">.babelrc</span>
{
  <span class="hljs-string">"plugins"</span>: [
    [<span class="hljs-string">"lightscript"</span>, {
      <span class="hljs-string">"stdlib"</span>: {
        <span class="hljs-string">"require"</span>: <span class="hljs-literal">true</span>,
      }
    }]
  ]
}
</code></pre>
<h2>Automatic Semicolon Insertion</h2>
<p><em>See the <a href="#asi-tldr">tl;dr</a> for a quick overview</em></p>
<p>90% of the time, JavaScript’s Automatic Semicolon Insertion feature works every time.
That is, in most JavaScript code, semicolons are unnecessary.</p>
<p>But there are <a href="http://inimino.org/~inimino/blog/javascript_semicolons">a handful</a>
of cases where a semicolon needs to be inserted, as encoded in
<a href="http://eslint.org/docs/rules/semi#options">the eslint <code>semi: &quot;never&quot;</code> rule</a>:</p>
<blockquote>
<p>statements beginning with <code>[</code>, <code>(</code>, <code>/</code>, <code>+</code>, or <code>-</code></p>
</blockquote>
<p>ES6 and JSX each introduce an additional ambiguity: <code>`</code> and <code>&lt;</code>, which are handled as well.</p>
<p>LightScript solves each issue in a slightly different way,
though each fix is essentially an encoding of stylistic best-practice into the syntax itself.</p>
<p>In practice, if you stick to community-standard code style,
you should not have to worry about any of this; they are documented for completeness.</p>
<h3><code>+</code> and <code>-</code>: binary vs. unary</h3>
<p>There are two possible interpretations of this code:</p>
<pre><code>1
-1
</code></pre>
<p>It could either be a <code>1</code> statement followed by a <code>-1</code> (negative one)
statement, or a single <code>1 - 1</code> statement.
JavaScript chooses <code>1 - 1</code>, which is typically undesired.</p>
<p>This is because <code>+</code> and <code>-</code> take two forms in JavaScript:
<em>binary</em> (add or subtract two numbers) and <em>unary</em>
(make a number positive or negative).</p>
<p>To resolve this ambiguity, LightScript requires that <em>unary</em> <code>+</code> and <code>-</code>
are not separated by a space from their argument.
That is, <code>-1</code> is “negative one” while <code>- 1</code> is invalid LightScript.</p>
<p>With this restriction in place, it easy to give preference to the unary form
when a <code>+</code> or <code>-</code> begins a line:</p>
<pre><code>1
+ 1

1+1

1
+1
</code></pre>
<p>Only the last example is a deviation from JavaScript,
which would interpret the two lines as <code>1 + 1</code>.</p>
<p>Again, beware that unary <code>+</code> and <code>-</code> cannot be followed by a space in LightScript:</p>
<pre><code>- 1
</code></pre>
<p>Without this fix, it would be difficult to implicitly return negative numbers:</p>
<pre><code>negativeThree() -&gt;
  three = 3
  -three
</code></pre>
<p>(This would be <code>const three = 3 - three;</code> in JavaScript).</p>
<p>Similarly, it would be difficult to have lists with negative numbers:</p>
<pre><code>numbers = [
  0
  -1
  -2
]
</code></pre>
<p>(Without this ASI fix, that’d be <code>const numbers = [0 - 1 - 2];</code>).</p>
<h3><code>/</code>: division vs. regular expression</h3>
<p>In JavaScript, the following code throws a SyntaxError:</p>
<pre><code>let one = 1
/\n/.test('1')
</code></pre>
<p>This is because it tries to parse the <code>/</code> at the start of the second line as division.
As you can see, LightScript does not share this problem.</p>
<p>LightScript makes a slightly crude generalization that draws from the same strategy
as <code>+</code> and <code>-</code> (above): Regular Expressions can’t start with a space character (<code></code>):</p>
<pre><code>/ \w/.test(' broken')
</code></pre>
<p>This doesn’t happen very often, and when it does, can be trivially fixed
by escaping the space or using a <code>\s</code> character:</p>
<pre><code>/\ \w/.test(' not broken')

/\s\w/.test(' not broken')
</code></pre>
<p>Similary, a division <code>/</code> that starts a line cannot be followed by a space:</p>
<pre><code>1
/2
</code></pre>
<p>This space is not required when the <code>/</code> does not start a line:</p>
<pre><code>1/2

1
/ 2
</code></pre>
<h3><code>(</code>: expressions vs. function calls</h3>
<p>This is perhaps the most frequently problematic ASI failure, and the most easily fixed.</p>
<p>In JavaScript, the following code would try to call <code>one(1 + 1)</code>, which is not what you want:</p>
<pre><code>two = one + one
(1 + 1) / 3
</code></pre>
<p>In LightScript, the opening paren of a function call must be on the same line as the function:</p>
<pre><code>doSomething(
  param)

doSomething (
  param
)

doSomething
  (param) // oops!
</code></pre>
<h3><code>[</code>: index-access vs. arrays</h3>
<p>In JavaScript, the following code would try to access <code>one[1, 2, 3]</code> which isn’t what you want:</p>
<pre><code>two = one + one
[1, 2, 3].forEach(i =&gt; console.log(i))
</code></pre>
<p>That’s because you often do see code like this:</p>
<pre><code>firstChild = node
  .children
  [0]
</code></pre>
<p>In LightScript, accessing an index or property using <code>[]</code> requires an indent:</p>
<pre><code>node
  .children
  [0]

node
.children
[0] // oops!
</code></pre>
<p>The required indent is relative to the line that starts a subscript chain.</p>
<p>Note that this rule also applies to the “numerical index access” feature:</p>
<pre><code>node
  .children
  .0

node
.children
.0 // oops!
</code></pre>
<h3><code>&lt;</code>: less-than vs. JSX</h3>
<p>In JavaScript, the following would be parsed as <code>one &lt; MyJSX</code> and break:</p>
<pre><code><span class="hljs-literal">two</span> = <span class="hljs-literal">one</span> + <span class="hljs-literal">one</span>
&lt;MyJSX /&gt;
</code></pre>
<p>LightScript solves this in a similar manner to <code>+</code>, <code>-</code>, and <code>/</code>:
a less-than <code>&lt;</code> that starts a line must be followed by a space:</p>
<pre><code>isMyNumberBig = bigNumber
  &lt;myNumber
</code></pre>
<p>is broken, but this works:</p>
<pre><code>isMyNumberBig = bigNumber
  &lt; myNumber
</code></pre>
<h3><code>`</code>: tagged vs. untagged templates</h3>
<p>In JavaScript, the following would be parsed as <code>hello`world`</code>:</p>
<pre><code>hello
`world`
</code></pre>
<p>As with function calls, a tagged template expression in LightScript must have
the opening <code>`</code> on the same line as the tag.</p>
<h3>ASI tl;dr</h3>
<p><strong>You never need semicolons in LightScript to separate statements.</strong></p>
<p>Instead, there are a few restrictions around edge cases:</p>
<ol>
<li>For positive and negative numbers, use <code>+1</code> and <code>-1</code> instead of <code>+ 1</code> and <code>- 1</code>.</li>
<li>Regular expressions that begin with a space must use <code>/\ /</code> or <code>/\s/</code>, not <code>/ /</code>.</li>
<li>When starting a line with binary <code>+</code>, <code>-</code>, <code>\</code>, or <code>&lt;</code>, the symbol must be followed by a space:</li>
</ol>
<pre><code>isOver100 = twoHundred
<span class="hljs-comment">  / four</span>
  + oneHundred
  -<span class="ruby"> fifty
</span>  &lt; myNumber
</code></pre>
<h2>Known Ambiguities</h2>
<p>Unfortunately, there are a few ambiguous corner-cases.
You are unlikely to hit them and there are easy fixes.</p>
<h3>Colons, Arrow, and Types</h3>
<p>If you have an <code>if</code> whose test is a function call,
and whose consequent is an arrow function without parentheses or curly braces, eg;</p>
<pre><code>if fn(): x =&gt; 4
</code></pre>
<p>it will parse as a function <code>fn() =&gt; 4</code> with type annotation <code>x</code>,
and then throw a SyntaxError: <code>Unexpected token, expected :</code>.</p>
<p>This can be corrected by wrapping the param in parens:</p>
<pre><code>if fn(): (x) =&gt; 4
</code></pre>
<h2>Deviations from JavaScript</h2>
<p>LightScript is a “rough superset” of JavaScript: <em>almost</em> all valid JavaScript
is valid LightScript.</p>
<p>This section aims to comprehensively document the cases where valid JavaScript
compiles differently (or breaks) in LightScript.</p>
<p>Most cases have been covered elsewhere in this documentation,
but are grouped here for convenience.</p>
<h3>Added keywords</h3>
<p><code>now</code>, <code>or</code>, <code>and</code>, and <code>not</code> are reserved words in LightScript.</p>
<h3><code>==</code> and <code>!=</code></h3>
<p>Perhaps the biggest semantic change, <code>==</code> compiles to <code>===</code> and <code>!=</code> compiles to <code>!==</code>.</p>
<h3>Bitwise operators</h3>
<p>All bitwise operators have been removed. The unary Bitwise NOT <code>~</code> has been repurposed
for <a href="#tilde-calls">Tilde Calls</a>.</p>
<p>Instead you may use the replacements (like <code>bitwiseNot(x)</code>) provided by the <a href="#standard-library">standard library</a>.</p>
<p>Bitwise assignment operators (<code>|=</code>, <code>&amp;=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&gt;&gt;&gt;=</code>)
remain but may be removed as well in the future.</p>
<h3>ASI Fixes</h3>
<p>See <a href="#automatic-semicolon-insertion">ASI</a> for a handful of breaking syntax changes,
mainly requiring or disallowing a space after an operator.</p>
<h3>Do-While requires newline or semicolon</h3>
<p>While in JavaScript, the following is valid:</p>
<pre><code>do {} while (x) foo()
</code></pre>
<p>It is illegal in LightScript. A <code>;</code> or newline must follow the <code>while</code> conidition,
regardless of whether parens are used.</p>
<h3>No newlines after <code>if</code>, <code>while</code>, <code>switch</code>, and <code>with</code></h3>
<p>While in JavaScript, the following are valid:</p>
<pre><code>if
  (condition) {
    result()
  }

while
(notDone())
doStuff()
</code></pre>
<p>They are illegal in LightScript. Instead, put the condition on the same line as the <code>if</code>
or use parens like so:</p>
<pre><code>if (
  condition and
  otherCondition
):
  result()

while (
  notDone() and
  notBoredYet()
):
  doStuff()
</code></pre>
<h3>Numbers with decimals</h3>
<p>Numbers in LightScript cannot begin or end with a <code>.</code>:</p>
<pre><code>.5
</code></pre>
<!-- -->
<pre><code>5.
</code></pre>
<p>Instead use the explicit decimal forms:</p>
<pre><code>0.5
5.0
</code></pre>
<h3>No Invisible Characters</h3>
<p>While invisible characters are legal in strings, the only ones allowed in code
are <code></code> (ascii-32), <code>\n</code> and <code>\r\n</code>. Tabs, non-breaking spaces, and exotic unicode
such as <code>\u8232</code> raise <code>SyntaxError</code>s.</p>
<h3>Blocks vs. Objects</h3>
<p>In LightScript, a <code>{</code> at the beginning of a line parses as the start of an object, not a block.
For example, the following code breaks in LightScript:</p>
<pre><code>if (true)
{
  // body goes here
  let x = 3
}
</code></pre>
<p>You must instead use the following style when using curly braces:</p>
<pre><code>if (true) {
  let x = 3
}
</code></pre>
<p>In the rare case that you wish to use an anonymous block, such as</p>
<pre><code>function foo() {
  // some code up here
  {
    // code in an anonymous block here
    let x = 'private!'
  }
  // more code down here
  let x = 5
}
</code></pre>
<p>you may prefix the anonymous block with a semicolon, as so:</p>
<pre><code>function foo() {
  // some code up here
  ;{
    // code in an anonymous block here
    let x = 'private!'
  }
  // more code down here
  let x = 5
}
</code></pre>
<p>Similarly, if using blocks with <code>switch</code>/<code>case</code>, you cannot write</p>
<pre><code>switch (foo) {
  case bar:
    {
      // contents of block here
      let x = 3
    }
}
</code></pre>
<p>and must instead write</p>
<pre><code>switch (foo) {
  case bar: {
    // contents of block here
    let x = 3
  }
}
</code></pre>
</div></div></div></div><script src="/bundle.js?t=1496507007878"></script></body></html>